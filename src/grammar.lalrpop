use crate::ast::{self, Expr};

grammar;

match {
    // delimiters
    "{", "}", "(", ")", "[", "]", ";", ":", ".", ",", "|",

    // declaration
    "let",

    // operators
    "=", "==", ">", "<", "+", "-", "*", "/",

    // syntax constructs
    "=>",

    // literals
    "true", "false",
    r"[0-9]+",         // int
    r"[0-9]+\.[0-9]+", // float
    r#""[^"]*""#,      // string

    // symbols
    r"[a-zA-Z_][a-zA-Z_0-9]*",  

}

pub Program: Vec<Expr> = {
    <exprs:ExprList> => exprs
};

ExprList: Vec<Expr> = {
    <first:Expr> ";" <rest:ExprList> => {
        let mut exprs = vec![first];
        exprs.extend(rest);
        exprs
    },
    <expr:Expr> ";" => vec![expr],
};

Expr: Expr = {
    Assignment,
    Equality,
};

Assignment: Expr = {
    "let" <i:Identifier> "=" <v:Expr> => Expr::Assignment(i, Box::new(v)),
};

Equality: Expr = {
    <l:Equality> "==" <r:Relational> => Expr::Eq(Box::new(l), Box::new(r)),
    Relational,
};

Relational: Expr = {
    <l:Relational> ">" <r:Addition> => Expr::Gt(Box::new(l), Box::new(r)),
    <l:Relational> "<" <r:Addition> => Expr::Lt(Box::new(l), Box::new(r)),
    Addition,
};

Addition: Expr = {
    <l:Addition> "+" <r:Multiplication> => Expr::Add(Box::new(l), Box::new(r)),
    <l:Addition> "-" <r:Multiplication> => Expr::Sub(Box::new(l), Box::new(r)),
    Multiplication,
};

Multiplication: Expr = {
    <l:Multiplication> "*" <r:Unary> => Expr::Mult(Box::new(l), Box::new(r)),
    <l:Multiplication> "/" <r:Unary> => Expr::Div(Box::new(l), Box::new(r)),
    Unary,
};

Unary: Expr = {
    "-" <expr:Unary> => Expr::Negate(Box::new(expr)),
    PostfixExpression,
};

// Stubbed out for now
PostfixExpression: Expr = {
    Primary,
};

// Stubbed out for now
Primary: Expr = {
    Literal => Expr::Literal(<>),
    Identifier => Expr::Identifier(<>),
    Function,
};

Literal: ast::Literal = {
    Int => ast::Literal::Int(<>),
    Float => ast::Literal::Float(<>),
    Str => ast::Literal::String(<>),
    Bool => ast::Literal::Bool(<>),
}

Identifier: String = {
    r"[a-zA-Z_][a-zA-Z_0-9]*" => <>.to_string(),
};

Function: Expr = {
    "|" "|" "=>" "{" <body:ExprList> "}" => Expr::Function(body),
};

Bool: bool = {
    "true" => true,
    "false" => false,
};

Int: i32 = {
    r"[0-9]+" => <>.parse().unwrap(),
};

Float: f64 = {
    r"[0-9]+\.[0-9]+" => <>.parse().unwrap(),
};

Str: String = {
    r#""[^"]*""# => <>[1..<>.len()-1].to_string(),  // Remove the first and last characters (the quotes)
};

