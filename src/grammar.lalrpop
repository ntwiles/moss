use crate::ast::untyped::{Expr, Stmt, FuncCall, FuncDeclare, Literal};
use crate::typing::{ProtoType};

grammar;

match {
    // delimiters
    "{", "}", "(", ")", "[", "]", ";", ":", ".", ",", "|",

    // declaration
    "let",

    // operators
    "=", "==", ">", "<", "<=", ">=", "+", "-", "*", "/",

    // syntax constructs
    "=>", "if", "else", "loop", "break",

    // literals
    "true", "false",
    r"[0-9]+",         // int
    r"[0-9]+\.[0-9]+", // float
    r#""[^"]*""#,      // string

    // symbols
    r"[a-zA-Z_][a-zA-Z_0-9]*",  

}

pub Program: Expr = {
    <exprs:StmtList> => Expr::Block(exprs)
};

StmtList: Vec<Stmt> = {
    <first:Expr> ";" <rest:StmtList> => {
        let mut stmts = vec![Stmt { expr: first }];
        stmts.extend(rest);
        stmts
    },
    <expr:Expr> ";" => vec![Stmt { expr }],
};

Expr: Expr = {
    Assignment,
    Equality,
    IfElse,
    Loop,
    Break,
};

TypeExpr: ProtoType = {
    Identifier => ProtoType::Atomic(<>),
    <base:Identifier> "<" <args:Comma<TypeExpr>> ">" => ProtoType::Applied(base, args),
};

// TODO: Support just if without else, and else elif chains.
IfElse: Expr = {
    "if" <cond:Expr> "{" <then_block:StmtList> "}" "else" "{" <else_block:StmtList> "}" => {
        Expr::IfElse(Box::new(cond), Box::new(Expr::Block(then_block)), Box::new(Expr::Block(else_block)))
    }
    // "if" <cond:Expr> "{" <then_block:StmtList> "}" => {
    //     Expr::IfElse(Box::new(cond), then_block, None)
    // },
};

Loop: Expr = {
    "loop" "{" <body:StmtList> "}" => Expr::Loop(Box::new(Expr::Block(body))),
};

Break: Expr = {
    "break" => Expr::Break,
};

Assignment: Expr = {
    "let" <i:Identifier> "=" <v:Expr> => Expr::Assignment(i, Box::new(v)),
};

Equality: Expr = {
    <l:Equality> "==" <r:Relational> => Expr::Eq(Box::new(l), Box::new(r)),
    Relational,
};

Relational: Expr = {
    <l:Relational> ">" <r:Addition> => Expr::Gt(Box::new(l), Box::new(r)),
    <l:Relational> "<" <r:Addition> => Expr::Lt(Box::new(l), Box::new(r)),
    <l:Relational> ">=" <r:Addition> => Expr::Gte(Box::new(l), Box::new(r)),
    <l:Relational> "<=" <r:Addition> => Expr::Lte(Box::new(l), Box::new(r)),
    Addition,
};

Addition: Expr = {
    <l:Addition> "+" <r:Multiplication> => Expr::Add(Box::new(l), Box::new(r)),
    <l:Addition> "-" <r:Multiplication> => Expr::Sub(Box::new(l), Box::new(r)),
    Multiplication,
};

Multiplication: Expr = {
    <l:Multiplication> "*" <r:Unary> => Expr::Mult(Box::new(l), Box::new(r)),
    <l:Multiplication> "/" <r:Unary> => Expr::Div(Box::new(l), Box::new(r)),
    Unary,
};

Unary: Expr = {
    "-" <expr:Unary> => Expr::Negate(Box::new(expr)),
    PostfixExpression,
};

PostfixExpression: Expr = {
    <primary:Primary> "(" <args:ExprList> ")" => Expr::FuncCall(FuncCall { func: Box::new(primary), args }),
    Primary,
};

ExprList: Vec<Expr> = Comma<Expr>;

// Stubbed out for now
Primary: Expr = {
    Literal => Expr::Literal(<>),
    Identifier => Expr::Identifier(<>),
    FuncDeclare,
};

Literal: Literal = {
    Int => Literal::Int(<>),
    Float => Literal::Float(<>),
    Str => Literal::String(<>),
    Bool => Literal::Bool(<>),
}

Identifier: String = {
    r"[a-zA-Z_][a-zA-Z_0-9]*" => <>.to_string(),
};

FuncDeclare: Expr = {
    "(" <params:ParameterList> ")" ":" <return_type:TypeExpr> "=>" "{" <stmts:StmtList> "}" => Expr::FuncDeclare(FuncDeclare{ params, return_type: Box::new(return_type), block: Box::new(Expr::Block(stmts)), is_closure: false }),
    "|" <params:ParameterList> "|" ":" <return_type:TypeExpr> "=>" "{" <stmts:StmtList> "}" => Expr::FuncDeclare(FuncDeclare{ params, return_type: Box::new(return_type), block: Box::new(Expr::Block(stmts)), is_closure: true }),
};

ParameterList: Vec<(String, String)> = Comma<Parameter>;

// Stubbed to support type annotations.
Parameter: (String, String) = {
    <ident:Identifier> ":" <ty:Identifier> => (ident, ty),
};

Bool: bool = {
    "true" => true,
    "false" => false,
};

Int: i32 = {
    r"[0-9]+" => <>.parse().unwrap(),
};

Float: f64 = {
    r"[0-9]+\.[0-9]+" => <>.parse().unwrap(),
};

Str: String = {
    r#""[^"]*""# => <>[1..<>.len()-1].to_string(),  // Remove the first and last characters (the quotes)
};

// Utility

Comma<T>: Vec<T> = {
    <item:T> "," <rest:Comma<T>> => {
        let mut list = vec![item];
        list.extend(rest);
        list
    },
    <item:T> => vec![item],
    => vec![],
};