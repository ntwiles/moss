use crate::ast::{self, Expr};

grammar;

match {
    "{", "}", "(", ")", "[", "]", ";", ":", ".", ",", "::", "::<", "=>",
    "let",
    "=", "==", ">", "<", "+", "-", "*", "/",

    r"[a-zA-Z_][a-zA-Z_0-9]*",  // symbols
    r"[0-9]+",                  // int literals
    r"[0-9]+\.[0-9]+",          // float literals
    r#""[^"]*""#,               // string literals
}

pub Program: Expr = {
    <expr: Expr> => expr
};

Expr: Expr = {
    Equality,
};

Equality: Expr = {
    <l:Equality> "==" <r:Relational> => Expr::Eq(Box::new(l), Box::new(r)),
    Relational,
};

Relational: Expr = {
    <l:Relational> ">" <r:Addition> => Expr::Gt(Box::new(l), Box::new(r)),
    <l:Relational> "<" <r:Addition> => Expr::Lt(Box::new(l), Box::new(r)),
    Addition,
};

Addition: Expr = {
    <l:Addition> "+" <r:Multiplication> => Expr::Add(Box::new(l), Box::new(r)),
    <l:Addition> "-" <r:Multiplication> => Expr::Sub(Box::new(l), Box::new(r)),
    Multiplication,
};

Multiplication: Expr = {
    <l:Multiplication> "*" <r:Unary> => Expr::Mult(Box::new(l), Box::new(r)),
    <l:Multiplication> "/" <r:Unary> => Expr::Div(Box::new(l), Box::new(r)),
    Unary,
};

Unary: Expr = {
    "-" <expr:Unary> => Expr::Negate(Box::new(expr)),
    PostfixExpression,
};

// Stubbed out for now
PostfixExpression: Expr = {
    Primary,
};

// Stubbed out for now
Primary: Expr = {
    Literal => Expr::Literal(<>),
};

Literal: ast::Literal = {
    Int => ast::Literal::Int(<>),
    Float => ast::Literal::Float(<>),
    Str => ast::Literal::String(<>),
}

Int: i32 = {
    r"[0-9]+" => <>.parse().unwrap(),
};

Float: f64 = {
    r"[0-9]+\.[0-9]+" => <>.parse().unwrap(),
};

Str: String = {
    r#""[^"]*""# => <>.to_string(),
};